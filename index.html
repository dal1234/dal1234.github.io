<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Capital Bikeshare</title>
<style>
    html,
    body {
        height: 100%;
        width: 100%;
    }
    body {
        margin: 0;
    }
    #map {
        width: 100%;
        height: 100%;
    }
    svg {
        position: relative;
    }
    path {
        fill: none;
        stroke-width: 3px;
    }
    path.true {
        stroke:#FE0000;
    }
    path.false {
        stroke:#990099;
    }
    circle {
        fill: #FFCB00;
    }
    #timebox {
        position:absolute;
        height:200px;
        width:300px;
        top:0;
        left:0;
        z-index:10;
        background:#000;
        color:white;
        margin:30px;
        padding:30px;
    }
    .areaChart {
        position: absolute;
        bottom: 0;
        background: #000;
    }
    .axis path,
    .axis line {
          fill: none;
          stroke: #FFF;
          shape-rendering: crispEdges;
          stroke-width:1;
    }
    .axis text {
      stroke:white;
    }
    .area {
      fill: #3366FF;
    }
    .empty {
        fill: #990099;
    }
</style>




<div id="map">
</div>

<script src="http://d3js.org/d3.v3.min.js"></script>

<script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
    
    
<script>
    
    var tiles = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',{
  attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'
});

    var map = L.map('map')
        .addLayer(tiles)
        .setView([38.9, -77.03237], 14);

    var svg = d3.select(map.getPanes().overlayPane).append("svg"),
        g = svg.append("g").attr("class", "leaflet-zoom-hide");

    var transform = d3.geo.transform({point: projectPoint}),
        d3path = d3.geo.path().projection(transform);

    d3.json('lines7.geojson', function (data) {
        
        var feature = g.selectAll("path")
            .data(data.features)
            .enter().append("path")
//            .attr("class", function (d) {return d.properties.route + " " + true})
            .attr("class", function (d) {
                if (d.properties.type == "Registered") {
                    return d.properties.route + " " + true;
            } else {
                return d.properties.route + " " + false;
            }
            })
            .attr("style", "opacity:0");
        
//         var feature = g.selectAll("path")
//            .data(data.features)
//            .enter().append("path")
//            .attr("class", function (d) {
//                if (d.properties.hasfare == true) {
//                    return "trip" + (d.properties.key * 2) + " " + d.properties.hasfare;
//                } else {
//                    return "trip" + ((d.properties.key * 2) + 1) + " " + d.properties.hasfare;
//                }
//            })
//            .attr("style", "opacity:0");

        var marker = g.append("circle");

        map.on("viewreset", reset);
        reset();
        
        var i = 0;
        
        function iterate() {
        console.log(i);
        var path = svg.select("path.leg_" + i)

        .attr("style", "opacity:0.3")
        .call(transition);

          //Get path start point for placing marker
          function pathStartPoint(path) {
            var d = path.attr("d"),
            dsplitted = d.split("L")[0].slice(1);
            return dsplitted;
          }
        var startPoint = pathStartPoint(path);
          
          marker.attr("r", 4)
            .attr("id", "marker")
            .attr("transform", "translate(" + startPoint + ")");
            
          function transition(path) {
              path.transition()
                .duration(300)
                .attrTween("stroke-dasharray", tweenDash)
              .each("end", function (d) {
                    if(i < 100) {
                        i++;
                        iterate();   
                    };
                });
          };

          function tweenDash() {  

            var l = path.node().getTotalLength();
              
            var i = d3.interpolateString("0," + l, l + "," + l); // interpolation of stroke-dasharray style attr
            return function(t) {
              var marker = d3.select("#marker");
              var p = path.node().getPointAtLength(t * l);
              marker.attr("transform", "translate(" + p.x + "," + p.y + ")");//move marker
              return i(t);
                }   
           }
    }

        iterate();
        

        // Reposition the SVG to cover the features.
        function reset() {
            var bounds = d3path.bounds(data),
                topLeft = bounds[0],
                bottomRight = bounds[1];
            svg.attr("width", bottomRight[0] - topLeft[0])
                .attr("height", bottomRight[1] - topLeft[1])
                .style("left", topLeft[0] + "px")
                .style("top", topLeft[1] + "px");
            g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");
            feature.attr("d", d3path);
        }
    });
    // Use Leaflet to implement a D3 geometric transformation.
    function projectPoint(x, y) {
        var point = map.latLngToLayerPoint(new L.LatLng(y, x));
        this.stream.point(point.x, point.y);
    }
</script>
Contact GitHub API Training Shop Blog About
Â© 2016 GitHub, Inc. Terms Privacy Security Status Help